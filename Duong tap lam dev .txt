-- üåå Executor Auto Beam v4 ‚Äì Sci-Fi Glow Edition (Visual only)
-- T·ª± ƒë·ªông b·∫≠t khi v√†o game; beam ch·ªâ xu·∫•t hi·ªán n·∫øu c√≥ ng∆∞·ªùi trong FOV 80
-- Hi·ªáu ·ª©ng: Beam t√≠m, Highlight m·ª•c ti√™u, Aura & Glow quanh b·∫°n, √¢m "lock-on"
-- Ch·ªâ client-side / visual

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local localPlayer = Players.LocalPlayer

-- C·∫•u h√¨nh
local FOV_DEG = 80            -- t·ªïng FOV (ƒë·ªô)
local MAX_DISTANCE = 200      -- kho·∫£ng c√°ch t·ªëi ƒëa (studs) ƒë·ªÉ x√©t m·ª•c ti√™u
local BEAM_WIDTH = 0.25
local BEAM_TEXTURE = "rbxassetid://1302071761"  -- texture plasma
local LOCK_SOUND_ID = "rbxassetid://9118826693" -- sound khi lock
local HUM_SOUND_ID = "rbxassetid://9118823106"  -- loop sound cho beam

-- C√°c bi·∫øn qu·∫£n l√Ω
local active = true           -- auto-on
local currentTarget = nil
local highlight, beam, att0, att1, glowPoint, loopSound = nil, nil, nil, nil, nil, nil
local auraEmitter = nil

-- T·∫°o aura + glow cho ch√≠nh ng∆∞·ªùi ch∆°i (visual)
local function createLocalAura()
	local char = localPlayer.Character
	if not char then return end
	local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
	if not root then return end

	-- PointLight (glow nh·∫π)
	if not glowPoint or not glowPoint.Parent then
		glowPoint = Instance.new("PointLight")
		glowPoint.Color = Color3.fromRGB(200,150,255)
		glowPoint.Range = 10
		glowPoint.Brightness = 1.6
		glowPoint.Parent = root
	end

	-- ParticleEmitter (aura tƒ©nh, locked to part)
	if not auraEmitter or not auraEmitter.Parent then
		auraEmitter = Instance.new("ParticleEmitter")
		auraEmitter.Name = "PurpleAuraEmitter"
		auraEmitter.Texture = "rbxassetid://6971861639"
		auraEmitter.Color = ColorSequence.new(Color3.fromRGB(180,100,255), Color3.fromRGB(255,200,255))
		auraEmitter.LightEmission = 1
		auraEmitter.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 2), NumberSequenceKeypoint.new(1, 3)})
		auraEmitter.Rate = 12
		auraEmitter.Lifetime = NumberRange.new(0.8, 1.2)
		auraEmitter.Speed = NumberRange.new(0)
		auraEmitter.Rotation = NumberRange.new(0, 360)
		auraEmitter.RotSpeed = NumberRange.new(0)
		auraEmitter.LockedToPart = true
		auraEmitter.Transparency = NumberSequence.new(0.3)
		auraEmitter.Parent = root
	end
end

local function destroyLocalAura()
	if auraEmitter then auraEmitter:Destroy(); auraEmitter = nil end
	if glowPoint then glowPoint:Destroy(); glowPoint = nil end
end

-- Helper: t√¨m ng∆∞·ªùi g·∫ßn nh·∫•t trong FOV v√† kho·∫£ng c√°ch
local function getClosestInFOV(totalFovDeg, maxDist)
	local camCFrame = Camera.CFrame
	local camPos = camCFrame.Position
	local camForward = camCFrame.LookVector

	local nearest, nearestDist = nil, math.huge
	for _, p in pairs(Players:GetPlayers()) do
		if p ~= localPlayer and p.Character and p.Character:FindFirstChild("Head") then
			local head = p.Character.Head
			local dir = head.Position - camPos
			local dist = dir.Magnitude
			if dist <= (maxDist or math.huge) then
				-- t√≠nh g√≥c gi·ªØa camera forward v√† vector t·ªõi head
				local dot = camForward:Dot(dir.Unit)
				local angle = math.deg(math.acos(math.clamp(dot, -1, 1)))
				if angle <= totalFovDeg/2 then
					if dist < nearestDist then
						nearestDist = dist
						nearest = p
					end
				end
			end
		end
	end
	return nearest, nearestDist
end

-- T·∫°o hi·ªáu ·ª©ng beam & highlight khi lock m·ª•c ti√™u
local function createLockEffects(targetPlayer)
	-- cleanup tr∆∞·ªõc
	if highlight then highlight:Destroy(); highlight = nil end
	if beam then beam:Destroy(); beam = nil end
	if att0 then att0:Destroy(); att0 = nil end
	if att1 then att1:Destroy(); att1 = nil end
	if loopSound then loopSound:Destroy(); loopSound = nil end

	if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("Head") then return end
	local myChar = localPlayer.Character
	if not myChar then return end
	local myHead = myChar:FindFirstChild("Head")
	if not myHead then return end
	local targetHead = targetPlayer.Character.Head

	-- Highlight (visual)
	highlight = Instance.new("Highlight")
	highlight.Adornee = targetPlayer.Character
	highlight.FillColor = Color3.fromRGB(180,100,255)
	highlight.FillTransparency = 0.5
	highlight.OutlineColor = Color3.fromRGB(255,255,255)
	highlight.Parent = targetPlayer.Character

	-- Attachments & Beam
	att0 = Instance.new("Attachment", myHead)
	att1 = Instance.new("Attachment", targetHead)

	beam = Instance.new("Beam")
	beam.Attachment0 = att0
	beam.Attachment1 = att1
	beam.Color = ColorSequence.new(Color3.fromRGB(180,100,255), Color3.fromRGB(255,200,255))
	beam.LightEmission = 0.9
	beam.Width0 = BEAM_WIDTH
	beam.Width1 = BEAM_WIDTH
	beam.Texture = BEAM_TEXTURE
	beam.TextureSpeed = 2
	beam.TextureLength = 4
	beam.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0), NumberSequenceKeypoint.new(1,0.35)})
	beam.FaceCamera = true
	beam.Segments = 15
	beam.CurveSize0 = 0.4
	beam.CurveSize1 = 0.4
	beam.Parent = myHead

	-- loop hum sound on player head (client-only)
	loopSound = Instance.new("Sound", myHead)
	loopSound.SoundId = HUM_SOUND_ID
	loopSound.Volume = 0.7
	loopSound.Looped = true
	-- pcall ƒë·ªÉ tr√°nh l·ªói n·∫øu asset b·ªã block
	pcall(function() loopSound:Play() end)
end

local function destroyLockEffects()
	if highlight then highlight:Destroy(); highlight = nil end
	if beam then beam:Destroy(); beam = nil end
	if att0 then att0:Destroy(); att0 = nil end
	if att1 then att1:Destroy(); att1 = nil end
	if loopSound then loopSound:Stop(); loopSound:Destroy(); loopSound = nil end
end

-- Ph√°t √¢m khi lock th√†nh c√¥ng
local function playLockSound()
	local s = Instance.new("Sound")
	s.SoundId = LOCK_SOUND_ID
	s.Volume = 0.8
	s.Parent = workspace:GetService("SoundService") or workspace
	pcall(function() s:Play() end)
	game:GetService("Debris"):AddItem(s, 2)
end

-- Main loop: t·ª± ƒë·ªông t√¨m & lock
RunService.RenderStepped:Connect(function()
	if not active then return end
	-- ƒë·∫£m b·∫£o aura t·ªìn t·∫°i
	if not auraEmitter or not auraEmitter.Parent then
		createLocalAura()
	end

	-- t√¨m m·ª•c ti√™u g·∫ßn nh·∫•t trong FOV
	local target = getClosestInFOV(FOV_DEG, MAX_DISTANCE)
	if target then
		-- n·∫øu m·ª•c ti√™u thay ƒë·ªïi
		if currentTarget ~= target then
			-- t·∫°o hi·ªáu ·ª©ng lock m·ªõi
			currentTarget = target
			destroyLockEffects()
			createLockEffects(target)
			playLockSound()
		else
			-- n·∫øu c√πng m·ª•c ti√™u, ki·ªÉm tra target c√≤n h·ª£p l·ªá
			if not target.Character or not target.Character:FindFirstChild("Head") then
				currentTarget = nil
				destroyLockEffects()
			end
		end
	else
		-- kh√¥ng c√≥ m·ª•c ti√™u ‚Üí x√≥a hi·ªáu ·ª©ng lock hi·ªán c√≥
		if currentTarget then
			currentTarget = nil
			destroyLockEffects()
		end
	end
end)

-- Cleanup & reattach aura when character spawns / respawns
local function onCharacterAdded(char)
	-- ch·ªù head/root
	task.delay(0.15, function()
		destroyLockEffects()
		destroyLocalAura()
		createLocalAura()
	end)
end

local function onPlayerRemoving(pl)
	if pl == currentTarget then
		currentTarget = nil
		destroyLockEffects()
	end
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

-- Initial: n·∫øu c√≥ character s·∫µn, t·∫°o aura
if localPlayer.Character then
	createLocalAura()
end

-- Khi t·∫Øt script (v√≠ d·ª• tho√°t), d·ªçn d·∫πp
game:BindToClose(function()
	destroyLockEffects()
	destroyLocalAura()
end)